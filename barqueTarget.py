import json
import os
import subprocess
import time
import shutil
from shutil import copyfile

import paramiko


class Target(object):
    """An object representing a VM or LXC container that is
    currently the target of a Barque operation. These are ephemeral
    and are generated by the Barque Worker process as needed, and
    destroyed when the task is complete or any situation which halts
    execution of this target's functions.
    This object contains all functions and operations which involve
    manipulating a VM or container. These functions must be blocking.
    The worker process is responsible for communicating with, and storing
    state in, the redis database.
    Each operation resturns boolean error and string message.
    """

    def __init__(self, vmid, resource_type, host, destination, file_target, proxconn, ceph_pool, ceph_vmdisk, ha_group):
        """Return a Target object whose proxmox vmid is *vmid*, job type is
        *job*, resource type (ct||vm) is *resource_type*, configured storage
        destination is *destination*, file target is *file_target*, and
        proxmoxer object connecting to proxmox as *proxconn*"""
        self.vmid = vmid
        self.resource_type = resource_type
        self.host = host
        self.destination = destination
        self.file_target = file_target
        self.proxconn = proxconn
        self.ceph_pool = ceph_pool
        self.ceph_vmdisk = ceph_vmdisk
        self.ha_group = ha_group
        self.client = paramiko.SSHClient()
        self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    def check_snapshot(self):
        """Check if barque snapshot exists in ceph.
        Returns boolean Error, boolean Exists, string Message
        Returns True if exists, False if not."""

        output = ""  # output of `rbd snap ls`
        try:
            output = subprocess.check_output(
                'rbd snap ls {}/{}'.format(self.ceph_pool, self.ceph_vmdisk), shell=True)
        except:
            return True, False, "Error reading snapshot list"
        if "barque" in output:
            return False, True, ""
        else:
            return False, False, ""

    def snapshot_create(self, undo=False):
        """Function for creating or removing (undo) the barque snapshot.
        Checks if snapshot already exists, and is aware of whether the operation
        is new or is being resumed from a prior attempt. If being resumed, will
        return error if prior snapshot does not exist (unless step is undo).
        returns boolean Error and string message."""

        error, exists, message = self.check_snapshot()
        if error:  # unable to read snapshots, big problem
            return True, message

        if not undo:
            if exists:
                return False, "barque snapshot already exists"
            try:
                subprocess.check_output(
                    'rbd snap create {}/{}@barque'.format(self.ceph_pool, self.ceph_vmdisk), shell=True)
            except:
                return True, "error creating barque snapshot"
            return False, "barque snapshot created"
        else:
            if not exists:
                return False, "barque snapshot does not exist"
            try:
                subprocess.check_output(
                    'rbd snap rm {}/{}@barque'.format(self.ceph_pool, self.ceph_vmdisk), shell=True)
            except:
                return True, "error removing barque snapshot"
            return False, "barque snapshot removed"

    def snapshot_protect(self, undo=False):
        error, exists, message = self.check_snapshot()
        if error:
            return True, message
        if not exists:
            return True, "barque snapshot does not exist"
        if not undo:
            try:
                subprocess.check_output(
                    'rbd snap protect {}/{}@barque'.format(self.ceph_pool, self.ceph_vmdisk), shell=True)
            except:
                return True, "unable to protect snapshot"
            return False, "snapshot protected"
        else:
            try:
                subprocess.check_output(
                    'rbd snap unprotect {}/{}@barque'.format(self.ceph_pool, self.ceph_vmdisk), shell=True)
            except:
                return True, "unable to unprotect snapshot"
            return False, "snapshot unprotected"

    def remove_recovery_snapshots(self):
        try:
            subprocess.check_output(
                "rbd snap purge {}/{}-barque".format(self.ceph_pool, self.ceph_vmdisk), shell=True)
        except:
            return True, "error removing snapshots"
        return False, "removed all snapshots"

    def copy_config(self):
        # Do we really need to copy config files? Yes - for snapshots. Silly proxmox.
        if self.resource_type == "ct":
            try:
                copyfile('/etc/pve/nodes/{}/lxc/{}.conf'.format(self.host, self.vmid),
                         "".join((self.destination, self.file_target, ".conf")))
            except:
                return True, "unable to copy config file"
            return False, "ct config file copied successfully"
        if self.resource_type == "vm":
            try:
                copyfile('/etc/pve/nodes/{}/qemu-server/{}.conf'.format(self.host, self.vmid),
                         "".join((self.destination, self.file_target, ".conf")))
            except:
                return True, "Unable to copy config file"
            return False, "vm config file copied successfully"

    def create_backup(self, undo=False):
        if not undo:
            try:
                subprocess.check_output(
                    "rbd export --rbd-concurrent-management-ops 20 --export-format 2 {}/{}@barque - | lz4 -1 - {}{}.lz4".format(self.ceph_pool, self.ceph_vmdisk, self.destination, self.file_target), shell=True)  # .split('\n') #run command then convert output to list, splitting on newline
            except:
                return True, "error creating backup file"
            return False, "backup file created"
        else:
            try:
                subprocess.check_output(
                    "rm {}.lz4".format(self.file_target), shell=True)
            except:
                return True, "error removing backup file"
            return False, "backup file removed"

    def check_in_ha(self):
        try:
            subprocess.check_output(
                "ha-manager status | grep {}".format(self.vmid), shell=True)
        except:
            return False, "not in ha"
        return True, "still in ha"

    def ha_remove(self, undo=False):
        if not undo:
            if not self.check_in_ha:
                return False, "already not in ha"
            try:
                subprocess.check_output(
                    "ha-manager remove {}:{}".format(self.resource_type, self.vmid), shell=True)
            except:
                return True, "error removing {} from ha-manager".format(self.vmid)
            return False, "removed from ha-manager"
        else:
            if self.check_in_ha:
                return False, "already in ha"
            try:
                subprocess.check_output("ha-manager add {}:{} -group {}".format(
                    self.resource_type, self.vmid, self.ha_group), shell=True)
            except:
                return True, "error adding {} to ha-manager with group {}".format(self.vmid, self.ha_group)
            return False, "added to ha-manager"

    def is_running(self, client):
        """Checks if target is currently running. Requires connected client as argument.
        Returns boolean error, boolean isRunning, string message"""

        command = ""
        if self.resource_type == "ct":
            command = "pct status {}".format(self.vmid)
        if self.resource_type == "vm":
            command = "qm status {}".format(self.vmid)

        _, stdout, _ = self.client.exec_command(command)
        for line in stdout:
            if "running" in line:
                return False, True, "target is running"
            if "stopped" in line:
                return False, False, "target is stopped"
        print("unable to determine target status")
        return True, True, "unable to determine target status"

    def stop(self, undo=False):
        self.client.connect(self.host, username='root')
        err, running, message = self.is_running(self.client)
        if err:
            self.client.close()
            return True, message
        if not undo:
            if not running:
                self.client.close()
                return False, "target already stopped"
            if self.resource_type == "ct":
                _, _, stderr = self.client.exec_command(
                    "pct stop {}".format(self.vmid))
                if stderr.channel.recv_exit_status() == 0:
                    self.client.close()
                    return False, "container stopped"
                self.client.close()
                return True, "error stopping container"

            if self.resource_type == "vm":
                _, _, stderr = self.client.exec_command(
                    "qm shutdown {}".format(self.vmid))
                if stderr.channel.recv_exit_status() == 0:
                    self.client.close()
                    return False, "vm shut down"
                self.client.close()
                return True, "error shutting down vm"
            self.client.close()
            return True, "resource type unrecognized!"
        self.client.close()

    def create_recovery(self, undo=False):
        if not undo:
            try:
                subprocess.check_output("rbd mv {}/{} {}/{}-barque".format(
                    self.ceph_pool, self.ceph_vmdisk, self.ceph_pool, self.ceph_vmdisk), shell=True)
            except:
                return True, "error creating disaster recovery image"
            return False, "disaster recovery image created"
        else:
            try:
                subprocess.check_output(
                    "rbd rm {}/{}-barque".format(self.ceph_pool, self.ceph_vmdisk), shell=True)
            except:
                return True, "error removing disaster recovery image"
            return False, "removed disaster recovery image"

    def recover(self):
        try:
            subprocess.check_output("rbd mv {}/{}-barque {}/{}".format(
                self.ceph_pool, self.ceph_vmdisk, self.ceph_pool, self.ceph_vmdisk), shell=True)
        except:
            return True, "error reverting to disaster recovery image"
        return False, "reverted to disaster recovery image"

    def remove_storage(self):
        try:
            time.sleep(5)
            try:
                subprocess.check_output(
                    'rbd rm {}/{}'.format(self.ceph_pool, self.ceph_vmdisk), shell=True)
            except subprocess.CalledProcessError:
                return True, "failed to remove vm disk"
            return False
        except:
            return True, "unable to remove vm disk"

    def extract_backup_image(self, undo=False):
        """Extracts a backup, as it is not possible to pipe this output into rbd import with image version 2"""
        if not undo:
            try:
                subprocess.check_output("lz4 -d {}{}.lz4 {}{}.img".format(
                    self.destination, self.file_target, self.destination, self.file_target), shell=True)
            except:
                return True, "unable to extract disk image"
            return False, "extracted disk image"
        else:
            try:
                os.remove("".join((self.destination, self.file_target, ".img")))
            except:
                return True, "unable to remove image"
            return False, "extracted image removed"
        return True, "nothing happened"

    def import_backup_image(self):
        try:
            subprocess.check_output("rbd import --export-format=2 {}{}.img {}/{}".format(
                self.destination, self.vmid, self.ceph_pool, self.ceph_vmdisk), shell=True)
        except:
            return True, "unable to import disk image to ceph"
        return False, "successfully imported disk image"

    def unmap_rbd(self):
        '''
        Uses rbd unmap to unmap the rbd device, over ssh to the target node.
        Accepts boolean argument "force" to include the -o force flag on if True, absent if False
        Returns True if the unmap command was successful.
        '''
        self.client.connect(self.host, username='root')
        err, running, message = self.is_running(self.client)
        if err or running:
            self.client.close()
            return True, message

        # ERROR CODES
        # 16 - Device or Resource busy
        # 22 - Not found
        # give ceph a change to finish any writes before attempting
        time.sleep(5)
        _, _, stderr = self.client.exec_command(
            "rbd unmap -o force {}/{}".format(self.ceph_pool, self.ceph_vmdisk))
        if stderr.channel.recv_exit_status() == 0:
            print("unmapped RBD device")
            return False, "unmapped RBD device"
        elif stderr.channel.recv_exit_status() == 16:
            print("16: device or resource busy")
            return True, "16: device or resource busy"
        elif stderr.channel.recv_exit_status() == 22:
            print("22: unable to find RBD device - invalid argument")
            return False, "22: invalid argument - unable to find device or is not mapped"
        else:
            print("unknown error during rbd unmap")
            return True, "unknown error during rbd unmap"

    def destroy(self):
        """
        Uses CLI destroy commands provided by Proxmox to forcefully remove a
        container or vm from the cluster.
        Returns boolean Error and string message
        """
        self.client.connect(self.host, username='root')
        err, running, message = self.is_running(self.client)
        if err or running:
            self.client.close()
            return True, message
        stderr = ""
        if self.resource_type == "ct":
            _, _, stderr = self.client.exec_command(
                "pct destroy {}".format(self.vmid))
        elif self.resource_type == "vm":
            _, _, stderr = self.client.exec_command(
                "qm destroy {} -skiplock".format(self.vmid))
        else:
            return True, "unable to determine resource type"

        if stderr.channel.recv_exit_status() == 0:
            return False, "successfully destroyed target"
        else:
            print("error code {}".format(stderr.channel.exit_status))
            return True, "error destroying target"

    def destroy_config(self):
        """
        Checks if the target's disk exists in Ceph. If it does not, then this
        function will destroy the config file of the target, which should cause
        proxmox to consider it deleted.
        Returns boolean Error and string message
        """

        try:
            subprocess.check_output(
                "rbd info {}/{}".format(self.ceph_pool, self.ceph_vmdisk), shell=True)
        except:
            # assume disk does not exist
            if self.resource_type == "ct":
                # TODO: Fix - fails if file does not exist
                os.remove(
                    '/etc/pve/nodes/{}/lxc/{}.conf'.format(self.host, self.vmid))
                return False, "removed configuration file"
            elif self.resource_type == "vm":
                os.remove(
                    '/etc/pve/nodes/{}/qemu-server/{}.conf'.format(self.host, self.vmid))
                return False, "removed configuration file"
            else:
                return True, "unable to determine resource type"
            return True, "unable to remove configuration file"
        return True, "disk still exists, will not remove config file"

    def create_config(self):
        """
        Overwrites the config file with the file stored with the backup. This is
        used to preserve snapshots. Additionally, this will overwrite all "net0"
        lines in a container's config file with whatever the current IP address
        is, in order to prevent an old backup from clobbering someone else's IP.
        This function reads the backup's config file and writes each line to the
        current config file line-by-line.
        """
        if self.resource_type == "ct":
            current_config = '/etc/pve/nodes/{}/lxc/{}.conf'.format(self.host, self.vmid)
            backup_config = "".join((self.destination, self.file_target, ".conf"))
            # Get current IP address
            ipline = ""
            with open(current_config, 'r') as current_conf:
                for line in current_conf:
                    if line.startswith('net0:'):
                        ipline = line
                        break

            # replace config file, injecting IP address
            with open(current_config, 'w') as current_conf:
                with open(backup_config, 'r') as backup_conf:
                    for line in backup_conf:
                        if line.startswith('net0:'):
                            current_conf.write(ipline)
                            continue
                        current_conf.write(line)
            return False, "ct config file copied successfully"
        elif self.resource_type == "vm":
            try:
                copyfile("".join((self.destination, self.file_target, ".conf")),
                         '/etc/pve/nodes/{}/qemu-server/{}.conf'.format(self.host, self.vmid))
            except:
                return True, "Unable to copy config file"
            return False, "vm config file copied successfully"
        else:
            return True, "unable to determine resource type"
        return True, "Error handling config file replacement"

    def update_config_disk(self):
        """
        For use with migration, re: tasks.skysilk.com/issues/2835
        Queries ceph for the size of the new disk. It then rolls thru the config
        file line-by-line until it finds the "rootfs" line and replaces the size
        field with the size returned by ceph.
        """
        # TODO: Properly handle snapshots that are stored with the backup

        # Get disk size from ceph
        disk_size = json.loads(
            subprocess.check_output(
                "rbd info {}/{} --format=json".format(
                    self.ceph_pool,
                    self.ceph_vmdisk),
                shell=True)
            )["size"] / 1073741824
        try:
            config_file = open(
                "/etc/pve/nodes/{}/lxc/{}.conf".format(self.host, self.vmid), "r")
        except Exception:
            return True, "Unable to read config file"

        #
        # Saving comment section below as notes for proper snapshot handling
        #

        # # Get snapshot list from ceph
        # snapshot_list = json.loads(
        #     subprocess.check_output(
        #         "rbd snap ls {}/{} --format=json".format(
        #             self.ceph_pool,
        #             self.ceph_vmdisk
        #         )
        #     ), shell=True
        # )
        # # Parse the config file
        # config_sections = {}
        # line_buffer = []
        # config_section_key = "head" # Config files begin with main section
        # for line in config_file:
        #     if line.startswith('['):
        #         # We've encountered a new snapshot section
        #         config_sections[config_section_key] = line_buffer
        #         line_buffer = []
        #         config_section_key = line[1:-2] # remove '[' and ']\n' characters
        #         continue
        #     if "rootfs" in line:
        #         sub = line.split(':')
        #         newline = sub[0] + ':' + sub[1] + ':' + \
        #             sub[2].split(',')[0] + ',' + str(disk_size) + "GB\n"
        #         new_file.write(newline)
        #     else:
        #
        # snapshots_configured = {}
        line_buffer = []
        try:
            first = True
            for line in config_file:
                if first:
                    if "rootfs" in line:
                        sub = line.split(':')
                        newline = sub[0] + ':' + sub[1] + ':' + \
                            sub[2].split(',')[0] + ',' + 'size=' + \
                            str(disk_size) + "G\n"
                        line_buffer.append(newline)
                    else:
                        if line.startswith('['):
                            first = False
                            line_buffer.append(line)
                        else:
                            line_buffer.append(line)
                else:
                    line_buffer.append(line)
        except Exception:
            config_file.close()
            return True, "Error parsing config files"
        # Close our files
        config_file.close()
        config_file = open(
            "/etc/pve/nodes/{}/lxc/{}.conf".format(self.host, self.vmid), 'w')
        config_file.writelines(line_buffer)
        config_file.close()

        # Since migration is a clean slate, remove any snapshots
        subprocess.check_output(
            "rbd snap purge {}/{}".format(self.ceph_pool, self.ceph_vmdisk), shell=True)

        return False, "new config file created"
